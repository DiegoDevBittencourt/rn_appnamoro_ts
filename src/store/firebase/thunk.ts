import firebase from "firebase";

import { convertDateFormatToHHMM } from '~/utils/functions';
import { handleThunkError } from "../error/thunk";
import { updateFirebaseUidOnRedux, updateFirebaseUserOnRedux, updateRealTimeFirebaseChat } from "./reducer";

const unsubscribeFirebaseListeners = [];

export function signInOrSignUpToFirebase() {//if there's no record try sign in, otherwise: sign up
    return async (dispatch: any, getState: any) => {

        // const userEmail = getState()?.users?.userData?.email;

        // const addUserOnFirestore = async (user: any) => {
        //     try {
        //         const db = firebase.firestore();

        //         await db.collection('users')
        //             .doc(user?.uid)
        //             .set({
        //                 mySqlUserId: userEmail,
        //                 uid: user?.uid,//generated by firebase
        //                 isOnline: true,
        //                 createdAt: new Date()
        //             });

        //         dispatch(updateFirebaseUidOnRedux(user?.uid));
        //     } catch (err) {
        //         dispatch(handleThunkError(err));
        //     };
        // }

        // firebase.auth().signInWithEmailAndPassword(userEmail, userEmail).then(user => {

        //     dispatch(updateFirebaseUidOnRedux(user?.user?.uid));
        //     dispatch(getRealtimeMessagesFromFirebase());

        //     dispatch(updateFirebaseUserOnRedux({ uid: user?.user?.uid }));

        // }).catch(err => {

        //     if (err.code === 'auth/user-not-found') {

        //         firebase.auth().createUserWithEmailAndPassword(userEmail, userEmail).then(user => {

        //             addUserOnFirestore({ uid: user?.user?.uid });

        //             dispatch(updateFirebaseUserOnRedux({ uid: user?.user?.uid }));

        //         }).catch(err => {
        //             dispatch(handleThunkError(err));
        //         })
        //     }
        //     else {
        //         dispatch(handleThunkError(err));
        //     }
        // })
    }
}

export function getRealtimeMessagesFromFirebase() {
    return (dispatch: any, getState: any) => {

        const { id: userId } = getState().dashboard.userData;

        const db = firebase.firestore();

        var realTimeFirebaseChat1: any[] = [];
        var realTimeFirebaseChat2: any[] = [];
        var realTimeFirebaseChatFinal = [];
        //I'm using this ^ two helper arrays cause firestore doesn't accept OR operator

        unsubscribeFirebaseListeners.push(
            db.collection('chat')
                .where('userId_1', '==', userId)
                .orderBy('createdAt', 'asc')
                .onSnapshot(async (querySnapshot) => {

                    realTimeFirebaseChat1 = [];

                    querySnapshot.forEach(doc => {
                        realTimeFirebaseChat1.push(doc.data());
                    });

                    unsubscribeFirebaseListeners.push(db.collection('chat')
                        .where('userId_2', '==', userId)
                        .orderBy('createdAt', 'asc')
                        .onSnapshot(async (querySnapshot) => {

                            realTimeFirebaseChat2 = [];

                            querySnapshot.forEach(doc => {
                                realTimeFirebaseChat2.push(doc.data());
                            });

                            realTimeFirebaseChatFinal = [];

                            realTimeFirebaseChatFinal = realTimeFirebaseChat1.concat(realTimeFirebaseChat2)
                                .sort((a, b) => b.createdAt - a.createdAt)//order all messages desc by date

                            realTimeFirebaseChatFinal = realTimeFirebaseChatFinal.map(item => ({
                                ...item,
                                hourMinute: convertDateFormatToHHMM(item.createdAt.toDate())
                            }));

                            realTimeFirebaseChatFinal = realTimeFirebaseChatFinal.map((item, index) =>
                                ({ ...item, id: (item.createdAt.nanoseconds + item.createdAt.seconds + index).toString() })
                            );

                            dispatch(updateRealTimeFirebaseChat(realTimeFirebaseChatFinal));
                        })
                    );
                })
        );
    }
}

export function sendMessageToFirebase(message: string, matchedProfileId: string) {
    return async (dispatch: any, getState: any) => {

        const db = firebase.firestore();

        await db.collection('chat')
            .add({
                userId_1: getState().dashboard.userData.id,
                userId_2: matchedProfileId,
                createdAt: new Date(),
                isView: false,
                message
            })
            .catch(err => {
                dispatch(handleThunkError(err));
            });
    }
}

export function removeAllConversationsFromThisMatch(matchedProfileId: string) {
    return async (dispatch: any, getState: any) => {

        const loggedUserId = getState().dashboard?.userData?.id;

        try {
            const db = firebase.firestore();

            const conversation1 = db.collection('chat')
                .where('userId_1', '==', loggedUserId)
                .where('userId_2', '==', matchedProfileId);

            conversation1.get().then(function (querySnapshot) {
                querySnapshot.forEach(function (doc) {
                    doc.ref.delete();
                });
            });

            const conversation2 = db.collection('chat')
                .where('userId_1', '==', matchedProfileId)
                .where('userId_2', '==', loggedUserId);

            conversation2.get().then(function (querySnapshot) {
                querySnapshot.forEach(function (doc) {
                    doc.ref.delete();
                });
            });

        } catch (err) {
            dispatch(handleThunkError(err));
        }
    }
}
